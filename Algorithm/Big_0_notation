TIL (Today I Learned)
---
# 2025.09.01
---
# 시간 복잡도 (Time Complexity)

알고리즘의 성능을 평가하는 대표적인 기준은 시간과 메모리.
그중에서도 주로 시간 복잡도를 Big-O 표기법으로 표현한다.

1. 시간 복잡도의 종류

최선 (Best Case): 입력이 가장 유리할 때 걸리는 시간

평균 (Average Case): 일반적으로 기대되는 시간

최악 (Worst Case): 입력이 가장 불리할 때 걸리는 시간 → 가장 중요!
(어떤 경우에도 안정적으로 동작하는 알고리즘을 구현해야 하기 때문)

따라서, 시간 복잡도는 보통 최악의 경우 기준으로 표기한다.

2. Big-O 표기법

알고리즘 실행 시간이 입력 크기 n에 대해 어떻게 증가하는지를 나타낸다.

O(1) : 입력 크기에 상관없이 일정한 시간 → 상수 시간
예: 배열에서 인덱스로 원소 접근

O(n) : 입력 크기에 비례해 시간 증가 → 선형 시간
예: 배열 전체 탐색

O(n²) : 중첩 반복문 → 제곱 시간
예: 버블 정렬, 선택 정렬

O(n log n) : n 크기 데이터를 분할해 정복 → 준선형 시간
예: 퀵 정렬, 병합 정렬, 힙 정렬

O(2^n) : 입력 크기에 따라 지수적으로 증가
예: 피보나치 수열을 단순 재귀로 계산

3. 그래프 이미지 없이 이해하기

O(1) : 항상 똑같다 (📦 고정된 상자 하나 열기)

O(n) : 입력 크기만큼 일한다 (👣 한 칸씩 걸어가기)

O(n²) : 입력 크기의 제곱만큼 일한다 (👥 모든 쌍을 비교)

O(n log n) : 나누고 합치는 과정 반복 (📚 책을 반으로 갈라 정렬 후 다시 합치기)

4. 재귀식과 시간 복잡도

재귀 호출을 포함하는 알고리즘은 재귀식으로 표현하고, 이를 Big-O로 환산한다.
예시:

단순 반복: T(n) = T(n-1) + O(1) → O(n)

분할 정복: T(n) = 2T(n/2) + O(n) → O(n log n)

5. 정리

알고리즘 성능 어필 = 시간 복잡도 + 메모리 사용량

특히 최악의 시간 복잡도를 Big-O로 분석할 줄 아는 게 핵심

재귀/분할정복 문제 → 수학적 귀납법 & 재귀식으로 시간 복잡도 계산 가능

✍️ 오늘 배운 핵심:

좋은 알고리즘은 어떤 입력에서도 안정적으로 동작해야 하며, 이를 보장하는 척도는 최악의 시간 복잡도(Big-O) 분석이다.
