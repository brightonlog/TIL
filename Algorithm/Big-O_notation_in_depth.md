# TIL
---
# 2025_09_02

## SW 문제해결

### SW 문제해결 역량이란?
프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 **큰 그림을 만드는 능력**

### 문제해결 과정
1.  문제를 읽고 이해
2.  문제를 익숙한 용어로 재정의
3.  어떻게 해결할지 계획 세우기 (설계)
    -   **이 과정에서 반드시 나와야 하는 것**
        -   **자료구조**: 자료를 어디다 담을지 (리스트, 이진트리 등)
        -   **알고리즘**: 어떻게 풀지
        -   → 이를 바탕으로 시간복잡도 계산하기
4.  계획 검증하기
5.  프로그램으로 구현하기
6.  어떻게 풀었는지 돌아보고, 개선 방법이 있는지 찾아보기

---

## 복잡도 분석

### 알고리즘
-   문제를 해결하기 위한 절차나 방법
-   유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
-   → 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

### 알고리즘의 효율
1.  **공간적 효율성**: 메모리 얼마나 쓰는가
2.  **시간적 효율성**: 작업을 완료까지 시간이 얼마나 걸리는가?
    -   시간적 효율성은 주로 입력 크기 n에 대한 연산 횟수로 나타냄

> 효율성을 뒤집어 표현하면 **복잡도(Complexity)** 가 됨. 복잡도가 높을수록 효율성은 저하됨 (반비례관계)

### 복잡도의 점근적 표기
-   시간 (or 공간)복잡도는 입력 크기(N, M 같은 애들)에 대한 함수로 표기. 이 함수는 주로 여러 개의 항을 가지는 다항식임.
-   이를 단순한 함수로 표현하기 위해 **점근적 표기(Asymptotic Notation)** 를 사용함.
-   입력 크기 n이 무한대로 커질 때를 가정해서 복잡도를 간단히 하기 위해 사용하는 표기법 ⇒ 그래서 상수 생략 가능 (N이 엄청나게 커지면 상수 1, 2 같은 애들은 신경 안 써도 된다는 마인드)

-   **O(Big-Oh) 표기법**: 최악 (최악일 때도 잘 돌아갑니다~)
-   **Ω(Big-Omega) 표기법**: 최선 (최선일 때 이만큼 빨리 돌아갑니다~)
-   **Θ(Big-Theta) 표기법**: 평균

### O(Big-Oh)-표기
-   O-표기는 복잡도의 점근적 상한을 나타냄.
-   복잡도가 `f(n) = 2n^2-7n+4`라면 `f(n)`의 O-표기는 `O(n^2)`
-   **최고차항만 남김**

### 자주 나오는 O-표기 유형
-   **O(logn)**: 로그(대수) 시간 / Logarithmic time
    -   한 번 호출할 때마다 탐색 범위가 반으로 줄어들 때.
-   **O(nlogn)**: 로그 선형 시간 / Log-linear time
-   **O(1)**: 상수 시간 / Constant time
-   **O(n)**: 선형 시간 / Linear time
-   **O(n^2)**: 제곱 시간 / Quadratic time
-   **O(n^3)**: 세제곱 시간 / Cubic time

---

## 코테 시간 복잡도 계산법 (Python)

코딩 테스트에서 시간 초과를 피하기 위해, 코드를 실행하기 전 내 풀이의 연산 횟수를 예측하는 방법입니다.

### 1. 핵심 원리: 왜 연산 횟수를 셀까?
PC 성능과 환경에 따라 코드 실행 시간은 달라집니다. 따라서 코딩 테스트에서는 절대적인 '시간'이 아닌, 정해진 시간 동안 **'몇 번의 연산을 수행하는가'** 를 기준으로 코드의 효율성을 평가함

### 2. 기준 성능: 1초에 몇 번?
-   **Python**: 약 2,000만 ~ 3,000만 번
-   **C++ / C**: 약 1억 번
-   **Java**: 약 5,000만 번

> **Tip!**
> Python의 경우, 보수적으로 **1초에 2,000만 번**의 연산이 가능하다고 가정하고 계산하면 안정적입니다.

### 3. 예산 계산법: 내 코드, 시간 안에 될까?
-   **Step 1. 총 연산 예산 파악하기**
    -   `(제한 시간)초 × (1초당 연산 횟수) = (총 연산 예산)`
    -   예시: 제한 시간이 2초라면? → 2초 × 2,000만 = **총 4,000만 번**의 연산 예산
-   **Step 2. 테스트 케이스 1개 당 예산 파악하기 (필요 시)**
    -   `(총 연산 예산) ÷ (총 테스트 케이스 수) = (TC 1개당 허용 연산 횟수)`
    -   예시: 총 예산 4,000만 번, TC가 50개라면? → 4,000만 ÷ 50 = **TC 1개 당 80만 번**

### 4. ⚠️ 시간 초과 예시: 이중 for문
-   **문제 상황**: 입력 N의 최댓값이 5,000일 때, 아래 코드는 시간 내에 동작할까요? (제한 시간 1초)
```python
n = 5000
count = 0
for i in range(n):
    for j in range(n):
        count += 1 # 연산 1회로 가정
연산 횟수 계산:

N × N 이므로, 5,000 × 5,000 = 25,000,000 (2,500만) 번

결론:

Python의 1초 예산은 약 2,000만 번입니다.

이 코드는 2,500만 번의 연산을 수행하므로 시간 초과가 발생할 가능성이 매우 높습니다.

사용을 피해야 할 내장 함수들
append()
강사님 왈: "데이터 만 개가 이상 들어오면, 그때부턴 append 안 씀"

append()가 느려질 수 있는 이유: 리스트의 공간이 꽉 찰 때마다 더 큰 공간으로 '이사'(메모리 재할당 및 복사)를 가기 때문. 데이터가 많을수록 이사 비용(시간)이 커짐.

데이터가 10만 개 들어올 경우 비교

< 안 쓸 방법 >

```python
li = []
for i in range(100000):
    li.append(i) 
< append 대체 방법 >

Python

li = [0] * 100000
idx = 0
for i in range(100000):
    li[idx] = i # input() 받는 부분
    idx += 1
표준 입출력 방법
표준 입출력 써야 하는 이유
시스템 상 복사의 문제점을 발견할 수 있다.

여러가지 TC를 만들면서 테스트할 수 있다.

디버깅할 때도 TC와 output을 보면서 할 수 있다.

문제에서 숨겨진 히든 테케를 찾기 위해서 계속 써야 함.

표준 입출력 방법
```python
import sys
sys.stdin = open("input.txt", "r")

a, b = map(int, input().split())
print(a, b, a+b)
sys.stdin : standard input (표준 입력)
```

open(): 파일을 열겠다

open(파일명, "r"): "r" = 읽기모드(read mode)

입출력 받는 step
```Python

# 파일 입출력
import sys
# 파일 입력 (open)
# r = read mode
# w = write mode
sys.stdin = open("input.txt", "r")
n = int(input())
print(n)
```
# 진법과 연산
## 진법
### 10진수: 사람이 사용하는 진수, 수 하나를 0 ~ 9로 표현

### 2진수: 컴퓨터가 사용하는 진수, 수 하나를 0, 1로 표현

### 8진수: 2진수를 더 가독성 있게 사용 (임베디드 분야)

### 16진수: 2진수를 더 가독성 있게 사용, 수 하나를 0, 1, …, 9, A, B, …, F로 표현 (컴퓨터 개발)

### 왜 16진수를 사용하는가?
2진수 → 10진수 변환 시

→ 인간이 이해하기 편하지만 연산이 오래 걸림

2진수 → 16진수 변환 시

→ 인간이 이해하기 편하면서, 연산 속도가 매우 빠름
