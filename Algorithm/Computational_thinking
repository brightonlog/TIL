# TIL (2025-09-01)

## 📝 오늘 배운 것

### 1. 논리 (Logic)
- **Hard Logic**: 참/거짓 판별 규칙  
- **Soft Logic**: 경험적/직관적 판단  
- **명제**: 참이나 거짓을 판별할 수 있는 문장 (예: `1+1=2`)  
- **조건 명제**: `p → q`  
  - 대우(`¬q → ¬p`)는 항상 원래 명제와 동일한 참/거짓  
- **증명 방법**
  - 직접 증명
  - 간접 증명 (대우, 모순법)
  - 수학적 귀납법 (n=1 → n=k → n=k+1)

---

### 2. 수와 표현
- `k`개의 비트로 표현 가능한 범위: `0 ~ 2^k - 1`  
- `log₂n`: n을 표현하는데 필요한 비트 수  
  - 예) log₂8 = 3 → 8을 표현하려면 3비트 필요  

---

### 3. 집합과 조합론
- 집합의 포함 증명: A ⊆ B → A의 임의 원소가 B에 속함을 보이면 됨  
- 두 집합의 같음 증명: A ⊆ B, B ⊆ A  
- 조합 공식:  
  \[
  nCk = \frac{n!}{k!(n-k)!}
  \]  
- **귀류법**: 명제를 부정 → 모순 발생 → 원래 명제가 참  

---

### 4. 기초 수식 & 시간 복잡도
- 알고리즘 성능은 **최악의 경우** 기준으로 분석 → **Big-O 표기법**
- 주요 시간 복잡도:
  - O(1): 상수  
  - O(n): 선형  
  - O(n²): 중첩 반복문  
  - O(n log n): 분할 정복 (예: Merge Sort)  

---

### 5. 재귀 (Recursion)
- 함수가 자기 자신을 호출  
- **수학적 귀납법 원리**와 유사  
- 사용 시점: 반복 깊이가 입력값에 따라 달라질 때  

---

### 6. 동적 계획법 (Dynamic Programming)
- **Memoization (Top-down)**: 재귀 + 캐싱  
- **DP Table (Bottom-up)**: 점화식으로 차례대로 계산  
- 핵심: **중복 계산을 피하고 저장한 값 재활용**  

---

## 💡 오늘의 핵심
- **논리와 증명** → 알고리즘 타당성의 근거  
- **Big-O** → 알고리즘 성능을 설명하는 핵심 지표  
- **재귀 & DP** → 문제 해결의 강력한 도구  

---

👉 오늘은 특히 **시간 복잡도(Big-O)** 분석을 중점적으로 학습했고,  
효율적인 알고리즘을 증명/설명할 때 필수적으로 사용된다는 걸 배움.
