# 🗂 알고리즘 - STACK

## 📅 2025.08.14 목

---

## 🧮 Stack 계산기  

### 중위 표기법 (Infix)  
- 연산자가 피연산자 사이에 위치  
- 예: `A + B`  

### 후위 표기법 (Postfix)  
- 연산자가 피연산자 뒤에 위치  
- 예: `AB+`  

#### 변환 핵심  
- **icp (in-coming priority)**: 스택 밖 우선순위  
- **isp (in-stack priority)**: 스택 안 우선순위  

규칙:  
1. 피연산자 → 결과(postfix)에 추가  
2. 연산자 → 우선순위 비교 후 push/pop  
3. `)` → `(` 만날 때까지 pop  

#### 후위 표기법 계산  
1. 피연산자 → push  
2. 연산자 → pop 2개 → 연산 → 결과 push  
3. 마지막 스택 값 = 최종 결과  

---

## 🌲 Stack 응용  

### 1. Backtracking  
- 해가 될 수 없는 경로는 **Pruning(가지치기)** 하고 되돌아감  
- DFS와 유사하지만 불필요한 경로를 조기에 차단  
- 대표 문제: N-Queens, 미로 찾기, 스도쿠  

### 2. 순열 (Permutation)  
- **순서 O, 중복 X**  
- used 배열로 방문 기록 관리  

### 3. 중복 순열 (Repetition Permutation)  
- **순서 O, 중복 O**  
- 예: 주사위 굴리기  

### 4. 부분집합 (Subset)  
- 각 원소마다 "뽑는다/안 뽑는다" → branch = 2  

#### 비트연산 핵심 공식  
1. 전체 부분집합 개수 = `1 << n`  
2. 원소 포함 여부 = `if tar & 1`  
3. 다음 비트로 이동 = `tar >>= 1`  

### 5. 조합 (Combination)  
- **순서 X, 중복 X**  
- 예: 5명 중 3명 뽑기  

---

## ✅ 오늘의 핵심 요약  
1. 중위 → 후위 변환 원리 직접 구현  
2. 후위 표기법 계산 과정 손으로 따라하기  
3. Backtracking = DFS + Pruning  
4. 순열 / 중복 순열 / 부분집합 / 조합 → 모두 재귀 + path(스택) 기반  
5. 부분집합 개수 = `1 << n` 공식 암기  
